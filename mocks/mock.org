* system mock

this is an end-to-end mock describing the real-time facial expression API

** DONE installation

to set up dependencies for this system mock

#+BEGIN_SRC shell
npm install
#+END_SRC

to set up for the first time,
open mock.org in emacs and tangle with =C-c C-v t=

finally, to run the mock,

#+BEGIN_SRC shell
bash run-mock.sh
#+END_SRC

** developing

this is written in a literate style, in org mode.

if you choose to develop in org mode, you'll just need to 

=C-c C-v t=

to tangle all the output. then, you can =bash run-mock.sh= as usual, or execute code blocks from within org mode with =C-c C-c=

* source
here is all the source - including specs and tests.
** DONE affectiva cli client mock

the affectiva api takes an image/video, and outputs json over stdout.


*** DONE an affectiva CLI mock

since the affectiva CLI tool isn't done yet, let's use this sample to make a mock. the mock will simulate the CLI tool's behavior.

let's wrte this this mock in =affectiva-cli-mock.js=

#+BEGIN_SRC js :tangle affectiva-cli-mock.js
#! /usr/local/bin/node

'use strict';
#+END_SRC

**** sample json

here is a sample of the affectiva CLI client's JSON output

#+BEGIN_SRC js :tangle affectiva-cli-mock.js 
var sample_data = [{
    "date and time" : "1-19-2016 14:9:33",
    "timestamp" : 0.000000,
    "measurements" : {
        "yaw" : -0.063200,
        "roll" : 7.547718,
        "interoculardist" : 243.320160
    },
    "expressions" : {
        "smile" : 0,
        "innerBrowRaise" : 0,
        "browRaise" : 0,
        "browFurrow" : 0,
        "noseWrinkle" : 0,
        "upperLipRaise" : 0,
        "lipCornerDepressor" : 0,
        "chinRaise" : 0,
        "lipPucker" : 1,
        "lipPress" : 0,
        "lipSuck" : 0,
        "mouthOpen" : 0,
        "smirk" : 0,
        "eyeClosure" : 0,
        "attention" : 98
    },
    "emotions" : { 
        "joy" : 0,
        "fear" : 0,
        "disgust" : 0,
        "sadness" : 0,
        "anger" : 0,
        "surprise" : 0,
        "contempt" : 0,
        "valence" : 0,
        "engagement" : 0
    }
}]
#+END_SRC

when we call it on an image,
it outputs the json over stdout

*** the mock

#+BEGIN_SRC js :tangle affectiva-cli-mock.js
var printJson = () => console.log(JSON.stringify(sample_data))
setTimeout(printJson, 1000)
#+END_SRC

now we should be able to run that script as if it were the affectiva cli client

(we don't pass it an image, for now)

#+BEGIN_SRC shell
node affectiva-cli-mock.js
#+END_SRC

*** DONE specs for the affectiva API

here's a test that the affectiva CLI client should pass.

we'll save this test as =test-affectiva-cli-specs.js=

this script takes a shell command =-b= to execute, e.g.

#+BEGIN_SRC shell
node affectiva-cli-specs.js -b "node affectiva-cli-mock.js -i my-image.png"
#+END_SRC

ok, a test spec in tape:

#+BEGIN_SRC js :tangle test-affectiva-cli-specs.js
var test = require('tape'),
    argv = require('minimist')(process.argv.slice(2)),
    exec = require('child_process').exec

console.log('bin to execute', argv.b)

function checkCLIOutput (t, cliBinPath) {
    exec('./' + cliBinPath, (err, stdout, stderr) => {
        // should call the executable correctly
        t.notOk(err, 'should be no error in calling')
        t.notOk(stderr, 'should be no error from process\'s stdout')
        t.ok(stdout, 'result should exist')
        // executable's stdout should be parseable as json
        var j = JSON.parse(stdout)
        t.ok(j, 'result should be valid json')
        // check it has some key fields
        t.ok(j[0], 'result should be a list')
        t.ok(j[0].expressions, 'object should have expressions field')
        t.ok(j[0].emotions, 'object should have emotions field')
        t.equals(0, j[0].timestamp, 'object should have timestamps field, where first item is 0')
        t.ok(j[0]['date and time'], 'object should have \'date-and-time\' field')
        // we're done
        t.end()
    })
}

test('test affectiva specs on shell command' + argv.s, t => {
  checkCLIOutput(t, argv.b)
})

#+END_SRC

*** DONE show the mock passes the existing tests

our mock should pass this test

#+RESULTS:

#+BEGIN_SRC shell :tangle run-mock.sh
# make the mock executable
chmod +x affectiva-cli-mock.js
# test the cli specs on the mock
node test-affectiva-cli-specs.js -b 'affectiva-cli-mock.js' | ./node_modules/.bin/tap-spec
#+END_SRC

** DONE working server

<2016-02-01 Mon 17:00>

the server handles POST requests. POST requests have an image or a video in the body. the server feeds this image to the affectiva-cli client.

the server takes a path to the affectiva binary with the option =-b=

*** DONE specs

let's write *another test with tape* to describe the specs of our server

**** DONE configuring the test

#+BEGIN_SRC js :tangle test-server.js
"use strict";
var test = require('tape'),
    spawn = require('child_process').spawn
// name our server binary
var server_cmd = './server.js'
// we'll just use the mock cli client ofr now
var affectiva_exe = 'affectiva-cli-mock.js'
#+END_SRC

**** DONE an affectiva executable =-b= should be passed over the command line
#+BEGIN_SRC js :tangle test-server.js
test('should require an executable -b from cli', t => {
    var proc = spawn(server_cmd)
    proc.stderr.on('data', e => {
      t.ok(e, 'should complain if i don\'t pass an executable -b to it')
      t.end()
    })
})
#+END_SRC

**** DONE accepts post requests 
#+BEGIN_SRC js :tangle test-server.js
test('a post request should get our mock json as a response', t => {
  function doTestRequest () {
    var request = require('request')
    // post a request to the endpoint
    request.post('http://localhost:8889', (err, res, body) => {
      // no errors
      t.notOk(err, 'should be no error')
      // response has a body
      t.ok(res, 'response exists')
      // 200 response
      t.equal(200, res.statusCode, '200 ok')
      // content-type headers are json
      t.equal(res.toJSON().headers['content-type'], 'application/json', 'application/json content headers')
      t.ok(JSON.parse(res.body)[0].emotions, 'response is parseable affectiva data, and seems to have the right schema.')
      proc.kill()
      t.end()
    })
  }
  // spawn [node server.js] -b [affectiva_exe]
  var proc = spawn(server_cmd, ['-b', affectiva_exe])
  // when the server says it's listening, do the test request
  proc.stdout.on('data', doTestRequest)
})
#+END_SRC

**** 
*** DONE server.js

server should run on 8889, take post requests to '/', and respond with json from the affectiva binary

**** DONE setup
we'll use [[https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options][child_process.spawn]] to run the affectiva cli, and [[http://expressjs.com/][express]] for our server

#+BEGIN_SRC js :tangle server.js
#! /usr/local/bin/node

var spawn = require('child_process').spawn,
    server = require('express')(),
    port = 8889
#+END_SRC

#+END_SRC

and, we take a path to the =affectiva_cli_binary= with a command line argument =-b=

#+BEGIN_SRC js :tangle server.js
var argv = require('minimist')(process.argv.slice(2))
var affectiva_cli_binary = argv.b
#+END_SRC

**** DONE assure that a binary -b was passed in

#+BEGIN_SRC js :tangle server.js
if (!affectiva_cli_binary) {
  process.stderr.write("ERR!!!! Pass a path to the affectiva cli binary with -b. e.g. node server -b my/affectiva-binary")
  process.exit(1)
}
#+END_SRC

**** DONE handle POST requests to / 

we'll exploit the fact that both the spawned process's stdout

#+BEGIN_SRC js :tangle server.js
server.post('/', (req, res) => {
  var proc = spawn(`./${affectiva_cli_binary}`)
  res.status(200)
  res.setHeader('Content-Type', 'application/json');
  proc.stdout.pipe(res)
})
#+END_SRC

**** DONE start the server

#+BEGIN_SRC  js :tangle server.js
server.listen(port, () => console.log(`listening on ${port}`))
#+END_SRC
** DONE e2e integration test

this is a full-system integration test:

#+BEGIN_EXAMPLE
POST req => server => affectiva CLI
                         ||
http res                 \/
 /\                      ||
 L L ===<<====<<====<<===.]
#+END_EXAMPLE

let's make sure the server is executable, then run the tests

#+BEGIN_SRC shell :tangle run-mock.sh
chmod +x server.js
node test-server.js | ./node_modules/.bin/tap-spec
#+END_SRC 

#+RESULTS:

* meta
** TODO a ./tangle.sh that produces all the source

here's a script that's supposed to do this

it works, but it leaves a linebreak before each file of tangled code

very annoying! it prevents some of the executables from working

#+BEGIN_SRC shell :tangle tangle.sh
# -*- mode: shell-script -*-
#
# tangle files with org-mode
#
# props to th.ing
# https://github.com/thi-ng/fabric/blob/master/tangle.sh

DIR=`pwd`

emacs -Q --batch \
--eval "(progn
(require 'org)(require 'ob)(require 'ob-tangle)(require 'ob-lob)
(setq org-confirm-babel-evaluate nil)
(mapc (lambda (file)
       (find-file (expand-file-name file \"$DIR\"))
       (org-babel-tangle)
       (kill-buffer)) '(\"mock.org\")))" \
#2>&1 |grep tangled


#+END_SRC
** DONE a ./run-mock.sh and run all the tests
done - that gets tangled through the script
